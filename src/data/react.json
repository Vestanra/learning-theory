[
    {
        "id":"r1",
        "question": "Для чого потрібний Virtual DOM у React?",
        "answer": "Віртуальний DOM - це легка копія реального DOM, яка існує лише в пам'яті. Зміни застосовуються до Virtual DOM, його стан порівнюється з попереднім станом, виявляються зміни, які необхідно застосувати до реального DOM і тільки ті частини, які змінилися оновлюються. Це дозволяє опимізувати продуктивність, оскільки реальний DOM є повільним. Virtual DOM групує зміни та виконує одночасний рендер замість безлічі дрібних."
    },
    {
        "id":"r2",
        "question": "Яка різниця між virtual DOM та shadow DOM?",
        "answer": "shadow DOM - це інструмент для веб-розробки, який дозволяє створювати міні-документи всередині основного документу, що дозволяє ізолювати частину коду, роблячи його незалежним від інших. Virtual - отимізація, мінімалізація маніпуляцій з реальним DOM, shadow - ізоляція стилів та логіки."
    },
    {
        "id":"r3",
        "question": "Яка різниця між state та props?",
        "answer": "props - передається в компонент ззовні. state - внутрішній стан компонента."
    },
    {
        "id":"r4",
        "question": "Яка різниця між класовим та функціональним компонентом?",
        "answer": "У класових компонентів є state, а у функціональних його немає. Але стан для функціонального компонента можна додати за допомогою хука useState. У класових компонентів є методи життєвого циклу, а у функціональних його немає. Але деякі методи життєвого циклу для функціонального компонента можна реалізувати за допомогою хука useEffect."
    },
    {
        "id":"r5",
        "question": "Які методи життєвого циклу є в React?",
        "answer": "В React є 3 фази: монтування, оновлення та розмонтування. У кожній із цих фаз є свої методи життєвого циклу. Монтування: constructor(), static getDerivedStateFromProps(), render(), componentDidMount(). Оновлення: static getDerivedStateFromProps(), shouldComponentUpdate(), render() - getSnapshotBeforeUpdate(), componentDidUpdate(). Розмонтування: componentWillUnmount(). Обробка помилок: static getDerivedStateFromError(), componentDidCatch()."
    },
    {
        "id":"r6",
        "question": "Як оновити state у класовому компоненті?",
        "answer": "Для того, щоб оновити стан у класовому компоненті, можна використовувати метод setState. Цей метод є асинхронним і React може згрупувати кілька викликів setState() в одне оновлення для поліпшення продуктивності. Метод setState може приймати функцію для того, щоб оновити стейт на основі вже наявного state. Виклик методу setState завжди призводить до оновлення компонента."
    },
    {
        "id":"r7",
        "question": "Чому setState асинхронна функція?",
        "answer": "Це потрібно для того, щоб React зміг згрупувати кілька викликів setState() в одне оновлення для покращення продуктивності. Виклик setState призводить до оновлення компонента, тому setState зробили асинхронною, щоб дочекатися поки всі компоненти викличуть setState() у своїх обробниках подій, перш ніж почати повторний рендер. Це позбавляє непотрібних повторних рендерів."
    },
    {
        "id":"r8",
        "question": "Що потрібно зробити, щоб компонент оновився?",
        "answer": "Для того, щоб оновився компонент потрібно: щоб змінився state, шляхом виклику метода setState; щоб змінилися props; викликати метод forceUpdate."
    },
    {
        "id":"r9",
        "question": "Як запобігти зайвому оновленню компонента?",
        "answer": "Існує кілька способів: реалізувати метод життєвого циклу shouldComponentUpdate, який скасовує рендер, якщо з нього повернути значення false; успадкуватися від PureComponent при створенні класового компонента."
    },
    {
        "id":"r10",
        "question": "Яка особливість PureComponent?",
        "answer": "В більшості випадків PureComponent можна використовувати замість написання власного shouldComponentUpdate. Але він робить лише поверхневе порівняння."
    },
    {
        "id":"r11",
        "question": "Для чого потрібні key?",
        "answer": "key - це спеціальний рядковий атрибут, який потрібно вказувати під час створення списку елементів. Ключі допомагають React визначати, які елементи були змінені, додані чи видалені. Їх необхідно вказувати, щоб React міг зіставляти елементи масиву з плином часу."
    },
    {
        "id":"r12",
        "question": "Що таке lazy?",
        "answer": "lazy — це функція з React, яка дозволяє динамічно імпортувати компоненти, що дає можливість оптимізувати завантаження додатку. Вона дозволяє відкладати завантаження компонентів до моменту їх фактичного використання, що зменшує обсяг початкового коду, який потрібно завантажити."
    },
    {
        "id":"r13",
        "question": "Для чого потрібні портали?",
        "answer": "Портали дозволяють відрендерити компонент у певний DOM-вузол. Чудова відповідь: Портали дозволяють рендерити дочірні елементи в DOM-вузол, що знаходиться поза DOM-ієрархією батьківського компонента."
    },
    {
        "id":"r14",
        "question": "Що таке refs?",
        "answer": "Рефи дають можливість отримати доступ до DOM-вузлів або React-елементів, створених у рендер-методі. Також рефи можуть зберігати в собі будь-яку іншу інформацію, окрім DOM-вузла."
    },
    {
        "id":"r15",
        "question": "Що таке context?",
        "answer": "Контекст дозволяє передавати дані через дерево компонентів без необхідності передавати пропси на проміжних рівнях. Чудова відповідь: У React-додатку дані передаються зверху вниз за допомогою props. Однак, подібний спосіб використання може бути надто громіздким для деяких типів props, які необхідно передавати до багатьох компонентів у додатку. Контекст надає спосіб ділитися такими даними між компонентами без необхідності явно передавати пропси через кожен рівень дерева."
    },
    {
        "id":"r16",
        "question": "Для чого потрібні render props?",
        "answer": "Render prop - це функція, яка повідомляє компоненту, що необхідно рендерити. Чудова відповідь: Render props - це можливість компонентів React розділяти код між собою за допомогою пропа, значенням якого є функція. Компонент із рендер-пропом бере функцію, яка повертає React-елемент, і викликає її замість реалізації власного рендеру."
    },
    {
        "id":"r17",
        "question": "Що таке HOCs?",
        "answer": "HOC - це функція, яка приймає компонент та повертає новий компонент."
    },
    {
        "id":"r18",
        "question": "Як реалізувати компонент запобіжника (Error Boundary)?",
        "answer": "апобіжники — це компоненти React, які виловлюють помилки JavaScript в будь-якому місці дерев їх дочірніх компонентів, зберігають їх у журналі помилок і виводять запасний UI замість дерева компонентів, що звалилося. Класовий компонент є запобіжником, якщо він реалізує хоча б один із методів життєвого циклу: static getDerivedStateFromError() або componentDidCatch()."
    },
    {
        "id":"r19",
        "question": "Які можливості надають хуки?",
        "answer": "Хуки дають можливість створювати state та додають методи життєвого циклу всередині функціонального компонента."
    },
    {
        "id":"r20",
        "question": "Які правила використання хуків?",
        "answer": "Хуки — звичайні JavaScript-функції, але є два правила, яких потрібно дотримуватися. Не викликайте хуки всередині циклів, умовних операторів чи вкладених функцій. Натомість завжди використовуйте хуки тільки всередині React-функцій або всередині власного хука, до повернення будь-якого значення з них. Також, при створенні власного хука, його ім'я має починатися з «use»"
    },
    {
        "id":"r21",
        "question": "Для чого потрібний useEffect?",
        "answer": "Хук useEffect дає можливість виконувати побічні ефекти у функціональному компоненті. Якщо передати функцію в useEffect, вона буде викликатися після кожного рендеру та оновлення. Якщо передати функцію та її залежність в useEffect, вона буде викликатися після рендеру і щоразу, коли її залежність змінюється. Якщо передати функцію в useEffect, яка повертає іншу функцію, ця функція буде викликана перед розмонтуванням компонента."
    },
    {
        "id":"r22",
        "question": "Чим відрізняється useEffect від useLayoutEffect?",
        "answer": "useEffect викликається після рендеру та оновлення компонента. useLayoutEffect викликається синхронно перед рендером та оновленням компонента. useLayoutEffect запускається у тій же фазі, що і componentDidMount та componentDidUpdate."
    },
    {
        "id":"r23",
        "question": "Що таке лінива ініціалізація стану в useState та useReducer?",
        "answer": "Коли початковий стан є результатом виклику якоїсь функції, його можна ініціалізувати ліниво для того, щоб при кожному оновленні компонента ця функція не викликалася. Для цього в useState або useReducer потрібно передати функцію, яка поверне початковий стан, і буде викликана лише один раз, під час першого рендеру."
    },
    {
        "id":"r24",
        "question": "Чим useRef відрізняється від createRef?",
        "answer": "Різниця в тому, що коли потрібно створити ref всередині функціонального компонента, використовуючи createRef, він буде створюватися щоразу, коли оновлюється компонент. Використовуючи useRef, він створюється 1 раз під час монтування."
    },
    {
        "id":"r25",
        "question": "Для чого потрібні useMemo та useCallback?",
        "answer": "Хук useMemo буде повторно обчислювати мемоізоване значення лише тоді, коли значення якоїсь із залежностей змінилося. Ця оптимізація допомагає уникнути дорогих обчислень під час кожного рендеру. Хук useCallback поверне мемоізовану версію колбека, який змінюється лише тоді, коли змінюються значення однієї із залежностей. Це корисно під час передачі колбеків оптимізованим дочірнім компонентам, які покладаються на рівність посилань для запобігання непотрібним рендерам."
    },
    {
        "id":"r26",
        "question": "Для чого потрібний redux?",
        "answer": "Redux - це бібліотека для керування станом програми. У звичайному додатку React компоненти мають свій state і можуть передавати його в якості props для дочірніх компонентів. У React-redux програмах є один глобальний state, на який підписуються компоненти, яким потрібно з нього читати дані."
    },
    {
        "id":"r27",
        "question": "Поясніть redux data flow",
        "answer": "Життєвий цикл даних у будь-якій Redux-програмі включає 5 кроків: 1 - викликається dispatch(action). Action - це простий javascript-об'єкт, який описує що трапилося. 2 - action потрапляє в middleware, і якщо це необхідно, запускає якийсь сайд-ефект. 3 - redux-стор викликає функцію-редюсер із двома аргументами: поточне дерево стану (state) та екшен (action). 4 - головний редюсер може комбінувати результат роботи кількох редюсерів у єдине дерево стану програми. 5 - redux-стор зберігає повне дерево стану, яке повертає головний редюсер."
    },
    {
        "id":"r28",
        "question": "Що таке redux middleware?",
        "answer": "Redux middleware надають сторонню точку розширення між відправкою екшену і моментом, коли цей екшен досягає редюсера. Redux middleware часто використовують для логування, повідомлення про помилки, спілкування з асинхронним API, роутингу тощо."
    },
    {
        "id":"r29",
        "question": "Де потрібно робити side effects в redux?",
        "answer": "Redux натхненний функціональним програмуванням і з коробки виконання побічних ефектів у ньому немає місця. Зокрема функції редюсера завжди повинні бути чистими функціями типу (state, action) => newState. Однак, мідлвари Redux-а дозволяють перехоплювати екшени та додавати до них складну поведінку, що включає побічні ефекти."
    },
    {
        "id":"r30",
        "question": "Що таке next() функція в redux middleware?",
        "answer": "Виклик next (action) в middleware призведе до того, що дія буде передана наступному middleware, а потім в редюсер. Це потрібно, щоб дотримуватися ланцюжка викликів middleware."
    },
    {
        "id":"r31",
        "question": "Для чого потрібні redux селектори?",
        "answer": "Селектори — це гетери для стану redux. Як і гетери, селектори інкапсулюють структуру стану та можуть використовуватися повторно. Селектори також можуть обчислювати похідні властивості."
    },
    {
        "id":"r32",
        "question": "Чим відрізняється action від action creator?",
        "answer": "action - це об'єкт, який описує, що сталося. action creator - це функція, яка може приймати якісь параметри та повертає action."
    },
    {
        "id": "r33",
        "question": "Що таке Rect Reconciliation?",
        "answer": "Reconciliation — це процес, який використовується для ефективного оновлення користувацького інтерфейсу. Він відповідає за порівняння старого та нового дерева віртуального DOM (Virtual DOM) і визначає мінімальні зміни, які потрібно внести у реальний DOM для його оновлення."
    },
    {
        "id": "r34",
        "question": "Що таке Rect Fiber?",
        "answer": "React Fiber — це переробка внутрішнього механізму рендерингу в React, яка була введена у версії React 16. Основна мета Fiber — зробити React більш гнучким і ефективним для рендерингу великих і складних інтерфейсів, дозволяючи переривати та відновлювати роботу з компонентами. Раніше React виконував рендеринг компонентів у 'синхронному' режимі, тобто він мав завершити оновлення всього дерева компонентів перед тим, як реагувати на інші події або взаємодії. Fiber дозволяє розбивати роботу на менші частини та виконувати їх поступово. Тобто React може призупинити роботу над великим рендером, виконати інші важливі завдання, а потім повернутися до рендерингу, коли є вільні ресурси."
    }
]