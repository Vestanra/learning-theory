[
    {
        "id":"js1",
        "question": "Які типи даних присутні в JavaScript?",
        "answer": "Існує 8 типів даних. 7 примітивних та 1 складний тип даних. Примітивні типи: number, string, boolean, symbol, bigInt, null, undefined. Складний тип - object. Він використовується для колекцій даних та для оголошення більш складних сутностей. Також він передається за посиланням, а прості типи даних за значенням."
    },
    {
        "id":"js2",
        "question": "Що таке NaN?",
        "answer": "NaN (not a number) - це значення, що отримується в результаті виконання числової операції над не числовим значенням. Його тип даних number. NaN не дорівнює самому собі. Перевірку на NaN можна зробити за допомогою Number.isNaN"
    },
    {
        "id":"js3",
        "question": "Яка різниця між null та undefined?",
        "answer": "undefined (невизначений) являє собою значення за замовчуванням: 1 - змінної, яку оголосили без ініціалізації; 2 - функції, яка нічого не повертає явно; 3 - неіснуючої властивості об'єкта. null - це значення «відсутності значення». Присвоюється змінній явно."
    },
    {
        "id":"js4",
        "question": "Чим відрізняється строга і нестрога рівність (=== та ==)?",
        "answer": "Строга рівність порівнює значення за типом даних та значенням. Нестрогa приводить значення до одного типу, а потім ці значення порівнює."
    },
    {
        "id":"js5",
        "question": "Чому результатом порівняння двох схожих об'єктів є false?",
        "answer": "Тому що об'єкти - це типи даних, що передаються за посиланням. 2 однакові на вигляд об'єкта мають різні посилання, і тому операція порівняння повертатиме false."
    },
    {
        "id":"js6",
        "question": "Як перевірити 2 об'єкти на ідентичність?",
        "answer": "1 - використовувати JSON.stringify для приведення об'єктів у рядок та порівняти їх вже як 2 рядки. Такий підхід має обмеження. Якщо в об'єкті будуть методи або symbol - JSON.stringify не зможе конвертувати їх у рядок. 2 - написати або використати з бібліотеки функцію deepEqual, яка буде проходити циклом по ключах двох об'єктів і перевірятиме значення цих ключів. Функція має працювати рекурсивно."
    },
    {
        "id":"js7",
        "question": "Як зробити копію об'єкта?",
        "answer": "Існує поняття глибокого та поверхневого копіювання. Для поверхневого копіювання можна використовувати spread оператор (...). Для глибокого - підхід JSON.stringify - JSON.parse для конвертування об'єкта в рядок і потім назад. Метод structuredClone(obj) або рекрусивна функція"
    },
    {
        "id":"js8",
        "question": "Чим відрізняються змінні var, let та const?",
        "answer": "var - змінну можна ініціалізувати після оголошення, можна змінювати, має функціональну область видимості, має hoisting. Зараз майже не використовують під час написання нового коду. let - змінну можна ініціалізувати після оголошення, можна змінювати, має блокову область видимості, не має hoisting. const - змінну обов'язково потрібно ініціалізувати під час оголошення, не можна змінювати, має блокову область видимості, не має hoisting.var - змінну можна ініціалізувати після оголошення, можна змінювати, має функціональну область видимості, має hoisting. Зараз майже не використовують під час написання нового коду. let - змінну можна ініціалізувати після оголошення, можна змінювати, має блокову область видимості, не має hoisting. const - змінну обов'язково потрібно ініціалізувати під час оголошення, не можна змінювати, має блокову область видимості, не має hoisting."
    },
    {
        "id":"js9",
        "question": "Як дізнатися чи є об'єкт масивом?",
        "answer": "Для цього можна використати метод Array.isArray."
    },
    {
        "id":"js10",
        "question": "Які перебираючі методи масивів ви знаєте?",
        "answer": "Є такі методи: forEach – для перебору масиву; filter – для фільтрації масиву; every/some – для перевірки масиву; map – для трансформації масиву в масив; reduce/reduceRight – для проходу по масиву з обчисленням значення; sort - сортує масив."
    },
    {
        "id":"js11",
        "question": "Як об'єднати масиви?",
        "answer": "Можна використовувати метод concat(). Можна використовувати spread оператор та об’єднати ці масиви в один загальний масив."
    },
    {
        "id":"js12",
        "question": "Як дізнатися чи знаходиться елемент у масиві?",
        "answer": "Використати метод includes, який повертає true якщо елемент знаходиться у масиві. Використати метод indexOf який повертає індекс знайденого елемента в масиві або -1 якщо елемента в масиві немає. також можна використати метод find, який повертає знайдений елемент, або повертає undefined."
    },
    {
        "id":"js13",
        "question": "Що таке підняття (hoisting)?",
        "answer": "Це механізм у JavaScript, в якому змінні типу var та оголошення функцій, пересуваються вгору своєї області видимості перед тим, як код буде виконаний."
    },
    {
        "id":"js14",
        "question": "Яким буде значення змінної var, якщо звернутися до неї до її оголошення?",
        "answer": "Значенням змінної буде undefined."
    },
    {
        "id":"js15",
        "question": "Що буде, якщо звернутися до змінної let/const до її оголошення?",
        "answer": "Буде помилка типу ReferenceError. Змінної ще не існує."
    },
    {
        "id":"js16",
        "question": "Що таке область видимості (Scope)?",
        "answer": "Гарна відповідь: Це область доступності змінної чи функції. Є глобальна, функціональна та блокова області видимості. Чудова відповідь: Це місце, де (або звідки) ми маємо доступ до змінних або функцій. JS має 4 типи областей видимості: глобальна, функціональна, блокова (ES6) та область видимості eval."
    },
    {
        "id":"js17",
        "question": "Чим Function Declaration відрізняється від Function Expression?",
        "answer": "Function Expression створюється, коли виконання доходить до нього, а потім вже може використовуватися. Function Declaration можна використовувати у всьому скрипті (або блоці коду, якщо функцію оголошено в блоці)."
    },
    {
        "id":"js18",
        "question": "Чим стрілочна функція відрізняється від звичайної?",
        "answer": "Стрілочна функція не має власного this. Вона бере його за місцем створення. У звичайній функції this визначається під час виклику. Стрілочна функція не має arguments, але може використовувати оператор залишкових параметрів ... Стрілочна функція не має prototype. Якщо містить лише одне виразне значення, можна не використовувати return, вона автоматично поверне результат цього виразу. Не може використовуватися як конструктор, і спроба викликати її з new призведе до помилки."
    },
    {
        "id":"js19",
        "question": "Що таке чиста функція?",
        "answer": "Вона для одного й того ж набору вхідних значень завжди повертає один і той же результат. Не змінює зовнішній стан або змінні за межами самої себе (не має побічних ефектів), тобто не взаємодіє з глобальними змінними, не виконує ввід/вивід, не змінює аргументи."
    },
    {
        "id":"js20",
        "question": "addEventListener, підписка - відписка",
        "answer": "Метод addEventListener дозволяє підписатися на події DOM-елементів, а за допомогою методу removeEventListener можна відписатися. Для того щоб відписатися від події, потрібно передати ту ж саму функцію, яка була використана при підписці. Передаємо назву події, на яку хочемо підписатися, функцію-обробник та об'єкт з додатковими опціями: once — подія виконається лише один раз, після чого автоматично відпишеться, capture — подія обробляється на фазі захоплення, passive — вказує, що обробник не буде викликати event.preventDefault(), що може покращити продуктивність на мобільних пристроях."
    },
    {
        "id":"js21",
        "question": "Що таке лексичне середовище (Lexical Environment)?",
        "answer": "Це концепція в JS, яка визначає, де і як ідентифікатори (змінні, функції) можуть бути доступними в коді. Це важлива концепція, що пояснює, як функції взаємодіють із зовнішніми змінними та як працює замикання (closures)."
    },
    {
        "id":"js22",
        "question": "Що таке замикання (Closures)?",
        "answer": "Це здатність функції запам'ятовувати своє лексичне оточення, тобто всі змінні, які були доступні на момент її створення, навіть після того, як зовнішня функція, в межах якої була оголошена ця функція, завершила виконання."
    },
    {
        "id":"js23",
        "question": "Для чого використовують замикання?",
        "answer": "1 - Часто для створення приватних змінних та функцій (інкапсуляція). 2 - Для збереження проміжних параметрів виклику функції (каррування)."
    },
    {
        "id":"js24",
        "question": "Що таке IIFE?",
        "answer": "Immediately Invoked Function Expression - це функція, яка викликається або виконується одразу після створення або оголошення."
    },
    {
        "id":"js25",
        "question": "Що таке this?",
        "answer": "Це посилання на контекст виклику функції. Контекстом є об'єкт, який в цей момент виконує або викликає функцію. Для стрілочної функції — це об'єкт у якому вона створена, а у звичайній функції — яким вона викликана.Контекстом може бути: 1 - this в об'єкті — вказує на сам об'єкт; 2 - this в класі — вказує на екземпляр класу; 3 - глобальним контекстом є window (або undefined в режимі use strict)"
    },
    {
        "id":"js26",
        "question": "Як можна підмінити контекст виклику функції?",
        "answer": "Є 3 методи: call, apply, bind. call та apply викликають функцію із заданим контекстом. bind повертає нову функцію із вже назавжди прив'язаним контекстом."
    },
    {
        "id":"js27",
        "question": "Чи можна змінити контекст функції, яку повернув метод bind?",
        "answer": "Ні, bind прив'язує контекст назавжди."
    },
    {
        "id":"js28",
        "question": "Чи можна підмінити контекст виклику стрілочної функції?",
        "answer": "Ні. Стрілочна функція не має методів call, apply, bind і своїх аналогів. Також вона використовує контекст у якому її створили, а не контекст у якому її викликали."
    },
    {
        "id":"js29",
        "question": "Що таке прототип об'єкта?",
        "answer": "Це шаблон об'єкта. Він використовується як запасний варіант для властивостей та методів, що існують у цьому об'єкті. Це також один зі способів обміну властивостями та функціональністю між об'єктами. Це основна концепція прототипного наслідування в JS."
    },
    {
        "id":"js30",
        "question": "Як працює прототипне наслідування в JavaScript?",
        "answer": "Коли ми хочемо прочитати властивість з об'єкта, а вона відсутня - JavaScript спробує прочитати його з прототипу об'єкта. Якщо властивості немає в прототипі, JavaScript намагатиметься його прочитати з прототипу прототипу, і т.д. доки властивість не буде знайдено або ланцюжок прототипів не закінчиться. У такому разі JavaScript поверне undefined."
    },
    {
        "id":"js31",
        "question": "Як створити об'єкт у якому не буде прототипу?",
        "answer": "Використати Object.create(). Цей метод приймає першим аргументом об'єкт, який буде прототипом об'єкта, який він поверне. Якщо ми викличемо Object.create() з аргументом null, буде створено об'єкт без прототипу."
    },
    {
        "id":"js32",
        "question": "Як перевірити чи є властивість об'єкта особистою властивістю або це властивість прототипу?",
        "answer": "Можна використовувати метод hasOwnProperty, який повертає true або false, в залежності від того, чи містить об'єкт зазначену властивість, як власну властивість, чи ні."
    },
    {
        "id":"js33",
        "question": "Як заборонити змінювати об'єкт?",
        "answer": "Є метод Object.freeze(), який заморожує об'єкт від змін. Цей метод працює тільки в один бік. Скасувати дію цього методу вже неможливо. Є метод Object.seal(), який забороняє додавати нові властивості, але вже наявні властивості можна змінювати. Також є метод Object.preventExtensions(), який забороняє додавати нові властивості в об'єкт."
    },
    {
        "id":"js34",
        "question": "Що таке дескриптори властивостей об'єкта?",
        "answer": "Дескриптор — це об'єкт конфігурації властивості в об'єкті. Він має 4 властивості: value - значення властивості об'єкта, writable - вказує чи можна змінювати значення цієї властивості, enumerable - вказує чи буде видно властивість під час перебору властивостей об'єкта, configurable - вказує чи можна додавати або видаляти властивості об'єкта, а також чи можна змінювати дескриптори його властивостей."
    },
    {
        "id":"js35",
        "question": "Чим відрізняється функція конструктор та клас?",
        "answer": "Клас — це синтаксичний цукор над функцією конструктора. Під час створення екземпляра класу, методи описані в ньому потрапляють у прототип, а методи описані всередині функції конструктора потраплять у сам екземпляр. Для того, щоб методи, описані всередині функції конструктора, потрапили в прототип, їх потрібно окремо туди додати."
    },
    {
        "id":"js36",
        "question": "Що потрібно зробити, щоб метод класу потрапив до його екземпляра?",
        "answer": "Такий метод слід описати всередині конструктора."
    },
    {
        "id":"js37",
        "question": "Чи є в JavaScript множинне наслідування?",
        "answer": "Ні, тому що наслідування в JavaScript базується на прототипах, а в одного об'єкта може бути лише один прототип."
    },
    {
        "id":"js38",
        "question": "Що таке Promise?",
        "answer": "Це об'єкт, який використовують для відкладених та асинхронних обчислень. Promise має 3 стани: - очікування (pending): початковий стан, не виконаний та не відхилений. - виконано (fulfilled): операцію завершено успішно. - відхилено (rejected): операцію завершено з помилкою."
    },
    {
        "id":"js39",
        "question": "Для чого потрібен метод Promise.all?",
        "answer": "Очікує виконання всіх промісів або відхилення будь-якого з них. Повертає проміс, який виконається після виконання всіх промісів. У випадку, якщо будь-який з промісів буде відхилено, Promise.all також буде відхилено. У нього є аналог Promise.allSetled, який виконується як тільки всі отримані проміси завершені (виконані або відхилені), що містить масив результатів виконання отриманих промісів."
    },
    {
        "id":"js40",
        "question": "Для чого потрібен метод Promise.race?",
        "answer": "Очікує виконання або відхилення будь-якого з отриманих промісів. Повертає проміс, який буде виконано або відхилено з результатом виконання першого виконаного або відхиленого промісу."
    },
    {
        "id":"js41",
        "question": "Для чого потрібна async/await функція?",
        "answer": "Ключове слово async робить створену функцію асинхронною. Функція async може містити вираз await, який призупиняє виконання функції async і чекає відповіді від переданого Promise, потім відновлює виконання функції async і повертає отримане значення."
    },
    {
        "id":"js42",
        "question": "Як обробляти помилки в async/await функції?",
        "answer": "Для цього можна використовувати конструкцію try...catch(). Викликати метод .catch() після виклику функції"
    },
    {
        "id":"js43",
        "question": " event loop?",
        "answer": "Це механізм, який дозволяє обробляти асинхронні події та керувати чергами операцій, щоб забезпечити неблокуючий, однопотоковий режим виконання. Алгоритм циклу подій: 1.Виконуються всі завдання зі стека викликів. 2.Якщо стек порожній, цикл подій перевіряє чергу мікрозадач і виконує всі мікрозадачі. 3.Якщо черга мікрозадач порожня, виконується перша макрозадача з черги макрозадач. 4.Після завершення кожної макрозадачі цикл подій знову перевіряє чергу мікрозадач. 5.Процес повторюється."
    },
    {
        "id":"js44",
        "question": "В чому різниця між cookie, sessionStorage та localStorage?",
        "answer": "localStorage: зберігає дані безстроково, очищається тільки за допомогою JavaScript або чищення кешу браузера, зберігає дані об'ємом до 5 МБ, не підтримується старими браузерами, наприклад, IE 7 та нижче, працює за правилом обмеження домену (same origin policy); sessionStorage: зберігає дані, доки триває поточна сесія вкладки, кожна вкладка має свій sessionStorage, зберігає дані об'ємом до 5 МБ, не підтримується старими браузерами, наприклад, IE 7 та нижче; cookie: зберігає дані, що передаються на сервер через заголовки, мають термін зберігання даних, обсяг даних від 4 Кбайт до 32 Кбайт, сookie можуть бути захищеними, в цьому випадку їх вміст не можна отримати на стороні клієнта. Це важливо для аутентифікації при зберіганні користувальницьких токенів."
    },
    {
        "id": "js45",
        "question": "Що таке делегування подій?",
        "answer": "Це техніка в JS, яка дозволяє обробляти події на батьківських елементах замість того, щоб додавати обробники подій до кожного окремого дочірнього елемента."
    },
    {
        "id":"js46",
        "question":"Що таке Map і Set?",
        "answer":"Map — це структура даних, яка зберігає пари ключ-значення, де кожен ключ унікальний. Ключі можуть бути будь-якого типу: рядки, числа, об'єкти тощо. Запам'ятовує порядок додавання елементів. Основні методи та властивості Map: new Map(); set(key, value); get(key); delete(key); has(key); clear(); size; forEach(callback); .keys(); values(). Set — це колекція унікальних значень. Вона дозволяє зберігати будь-які типи даних, але не допускає повторюваних елементів. add(value) замість set(key, value)"

    },
    {
        "id":"js47",
        "question":"Що таке WeakMap і WeakSet?",
        "answer":"WeakMap – це подібна до Map колекція, яка дозволяє використовувати лише об'єкти, як ключі і видаляє їх разом з пов'язаним значенням, коли вони стануть недоступними іншим засобам. WeakSet – це подібна до Set колекція, яка зберігає тільки об’єкти та видаляє їх після того, як вони стануть недоступними іншим засобам. Їх основна перевага полягає у тому, що вони мають слабке посилання на об'єкти, тому вони можуть бути легко видаленими збирачем сміття. Відсутностя підтримкф clear, size, keys, values, forEach"
    },
    {
        "id":"js48",
        "question":"Кастомні події?",
        "answer":"Дозволяють створювати події, які не є частиною стандартного набору подій браузера. Використовується конструктор CustomEvent. Можна вказати тип події та необов'язкові дані, які передаються разом з подією (об'єкт detail). Підписатися - addEventListener. Для виклику- метод dispatchEvent"
    },
    {
        "id":"js49",
        "question":"",
        "answer":""
    }
]